---
layout: post
head-img: https://s1.ax1x.com/2020/06/04/tw8zs1.jpg
# https://ww1.sinaimg.cn/large/babb3a97ly1gel7j2j5xaj20lc05sdg1.jpg
post: 
  title: MyBatis 入门
  type: article
date: 2018-05-23 20:32:00 +0800
categories: 
  - tech
tags: 
  - Mybatis
  - 入门
---
Ｍｙｂａｔｉｓ入门啦。

## 了解Mybatis
### 什么是Mybatis
　　MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。  
　　MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码（例如注册驱动、创建connection、创建statement）和手动设置参数以及获取结果集。  
　　MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。  
## Mybatis执行过程
1. 从 XML 中构建 SqlSessionFactory   
***SqlMapConfig.xml***   ，Mybatis的全局配置文件，包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）  
2. 从 SqlSessionFactory 中获取 SqlSession  
SqlSession，面向用户的接口，完全包含了面向数据库执行 SQL 命令所需的所有方法。
3. SqlSession 调用 Excutor（数据库操作执行器）操作数据库  
接口，负责sql语句动态生成和缓存的维护
4. 数据封装在MappedStatement  
MappedStatement类在Mybatis框架中用于表示XML文件中一个sql语句节点，即一个&lt;select />、&lt;update/>或者&lt;insert/>标签。Mybatis框架在初始化阶段会对XML配置文件进行读取，将其中的sql语句节点对象化为一个个MappedStatement对象。
5. 完成输入输出映射  
Mybatis中输入映射和输出映射可以是基本数据类型、hashmap、pojo、pojo的包装类型

## Mybatis入门开发
### 原始方式
#### 1、创建UserMapper
**UserMapper.xml**
````xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="test">
<select id="findUserById" parameterType="int" resultType="user">
	SELECT * FROM USER WHERE id= #{id}
</select>
</mapper>
````
#### 2、创建Pojo
**User.java**
````java
package cn.uhfun.webssm.po;
public class User {
    private String id;
    private String password;
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    @Override
	public String toString() {
		return "User{" +
				"id=" + id +
				", username='" + username + '\'' +
				'}';
	}
}
````
#### 3、引入mapper文件
**SqlMapConfig.xml**
````xml
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<properties resource="db.properties"/>
	<typeAliases>
		<package name="cn.itcast.mybatis.po"/>
	</typeAliases>
	<!-- 和spring整合后 environments配置将废除-->
	<environments default="development">
		<environment id="development">
			<transactionManager type="JDBC" />
			<dataSource type="POOLED">
				<property name="driver" value="${jdbc.driver}"/>
				<property name="url" value="${jdbc.url}"/>
				<property name="username" value="${jdbc.username}"/>
				<property name="password" value="${jdbc.password}"/>
			</dataSource>
		</environment>
	</environments>
	<mappers>
		<!-- 通过resource引用mapper的映射文件 -->
		<mapper resource="sqlmap/User.xml" />		
		<package name="cn.itcast.mybatis.mapper"/>
	</mappers>
</configuration>
````
#### 4、创建Dao接口
**UserDao.java**
````java
package cn.uhfun.mybatis.dao;
import java.util.List;
import cn.uhfun.mybatis.po.User;
public interface UserDao {
	//根据id查询用户信息
	public User findUserById(int id) throws Exception;
}
````
#### 5、实现Dao接口
**UserDaoImpl.java**
````java
package cn.uhfun.mybatis.dao;
import java.util.List;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import cn.uhfun.mybatis.po.User;
public class UserDaoImpl implements UserDao {
	private SqlSessionFactory sqlSessionFactory;
	// 将SqlSessionFactory注入
	public UserDaoImpl(SqlSessionFactory sqlSessionFactory) {
		this.sqlSessionFactory = sqlSessionFactory;
	}
	@Override
	public User findUserById(int id) throws Exception {
		// 创建SqlSession
		SqlSession sqlSession = sqlSessionFactory.openSession();
		// 根据id查询用户信息
		User user = sqlSession.selectOne("test.findUserById", id);
		sqlSession.close();
		return user;
	}
}
````
#### 6、编写测试类
**MyBatisTest.java**
````java
package cn.uhfun.mybatis;
import cn.uhfun.mybatis.dao.UserDao;
import cn.uhfun.mybatis.dao.UserDaoImpl;
import cn.uhfun.mybatis.po.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;
import java.io.InputStream;
public class MybatisTest {
    private SqlSessionFactory sqlSessionFactory;
    @Before
    public void init() throws IOException {
        String resource = "SqlMapConfig.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    @Test
    public void test1() throws Exception {
        UserDao userDao = new UserDaoImpl(sqlSessionFactory);
        User user = userDao.findUserById(1);
        System.out.print(user);
    }
}
````
#### 7、测试结果
````java
User{id=1, username='123'}
````
#### 原始方式存在的问题
1.  dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复（先创建sqlsession、调用sqlsession的方法、关闭sqlsession）

2. dao的实现 类中存在硬编码，调用sqlsession方法时将statement的id硬编码。

### Mapper代理方式
#### Mapper开发规范
1. mapper.xml中namespace指定为mapper接口的全限定名  
此步骤目的：通过mapper.xml和mapper.java进行关联。

````xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace命名空间，为了对sql语句进行隔离，方便管理 ，mapper开发dao方式，使用namespace有特殊作用
mapper代理开发时将namespace指定为mapper接口的全限定名
 -->
<mapper namespace="cn.uhfun.mybatis.mapper.UserMapper">
  <!-- 在mapper.xml文件中配置很多的sql语句，执行每个sql语句时，封装为MappedStatement对象
mapper.xml以statement为单位管理sql语句 -->
</mapper>
````
2. mapper.xml中statement的id就是mapper.java中方法名

  ````xml
  <mapper namespace="cn.uhfun.mybatis.mapper.UserMapper">
  <select id="findUserById" parameterType="int" resultType="user">
          SELECT * FROM USER WHERE id= #{id}
  </select>
  </mapper>
  ````
  UserMapper.java
  ````java
  public interface UserMapper {
      public User findUserById(int id) throws Exception;
  }
  ````
3. mapper.xml中statement的parameterType和mapper.java中方法输入参数类型一致
4. mapper.xml中statement的resultType和mapper.java中方法返回值类型一致.

#### 1、创建UserMapper
**UserMapper.xml**
````xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="cn.uhfun.mybatis.mapper.UserMapper">
<select id="findUserById" parameterType="int" resultType="user">
		SELECT * FROM USER WHERE id= #{id}
</select>
</mapper>
````
#### 2、创建Pojo
**User.java**
````java
package cn.uhfun.webssm.po;
public class User {
    private String id;
    private String password;
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    @Override
	public String toString() {
		return "User{" +
				"id=" + id +
				", username='" + username + '\'' +
				'}';
	}
}
````
#### 3、引入mapper文件
**SqlMapConfig.xml**
````xml
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<properties resource="db.properties"/>
	<typeAliases>
		<package name="cn.itcast.mybatis.po"/>
	</typeAliases>
	<!-- 和spring整合后 environments配置将废除-->
	<environments default="development">
		<environment id="development">
			<transactionManager type="JDBC" />
			<dataSource type="POOLED">
				<property name="driver" value="${jdbc.driver}"/>
				<property name="url" value="${jdbc.url}"/>
				<property name="username" value="${jdbc.username}"/>
				<property name="password" value="${jdbc.password}"/>
			</dataSource>
		</environment>
	</environments>
	<mappers>	
      <!-- 批量mapper配置 
		通过package进行自动扫描包下边的mapper接口，要求：需要mapper.xml和mapper.java同名并且在一个目录中-->
		<package name="cn.itcast.mybatis.mapper"/>
	</mappers>
</configuration>
````
#### 4、创建Mapper(Dao)接口
**UserMapper.java**
````java
package cn.uhfun.mybatis.UserMapper;
import java.util.List;
import cn.uhfun.mybatis.po.User;
public interface UserMapper {
	//根据id查询用户信息
	public User findUserById(int id) throws Exception;
}
````
#### 5、编写测试类
````java
package cn.uhfun.mybatis;
import cn.uhfun.mybatis.mapper.UserMapper;
import cn.uhfun.mybatis.po.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
public class MybatisTest {
    private SqlSessionFactory sqlSessionFactory;
    @Before
    public void init() throws IOException {
        String resource = "SqlMapConfig.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    @Test
    public void test() throws Exception {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        User user = userMapper.findUserById(1);
        System.out.print(user);
    }
}

````
#### 6、测试结果
````java
User{id=1, username='123'}
````
### 原始方式与mapper代理的区别
1. 原始dao开发方法，需要程序员编写dao接口和实现类，此方法在当前企业中还有使用，因为ibatis使用的就是原始dao开发方法。
2. mapper代理方法，程序员只需要写mapper接口（相当于dao接口），mybatis自动根据mapper接口和mapper接口对应的statement自动生成代理对象（接口实现类对象）。


## Mapper.xml加载方式
````xml
<mappers>
		<!-- 通过resource引用mapper的映射文件 -->
		<mapper resource="sqlmap/User.xml" />
		<!-- <mapper resource="mapper/UserMapper.xml" /> -->
		<!-- 通过class引用mapper接口 class：配置mapper接口全限定名
		要求：需要mapper.xml和mapper.java同名并且在一个目录 中
		-->
		<!-- <mapper class="UserMapper"/> -->
		<!-- 批量mapper配置 通过package进行自动扫描包下边的mapper接口，
		要求：需要mapper.xml和mapper.java同名并且在一个目录 中
		-->
		<package name="cn.itcast.mybatis.mapper"/>
	</mappers>
````

## XML配置
### properties属性
可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。  
比如：创建db.properties配置数据库连接参数。
````xml
<properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>
<dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>
````
注意： MyBatis 将按照下面的顺序来加载属性：  
* 在 properties 元素体内定义的属性首先被读取。 
* 然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 
* 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。

建议使用properties，不要在properties中定义属性，只引用定义的properties文件中属性，并且properties文件中定义的key要有一些特殊的规则。
### setting全局参数属性
　　mybatis运行时可以调整一些全局参数（相当于软件的运行参数），参考：mybatis-settings.xlsx
根据使用需求进行参数配置。
注意：小心配置，配置参数会影响mybatis的执行。

　　ibatis的全局配置参数中包括很多的性能参数（最大线程数，最大待时间。。。），通过调整这些性能参数使ibatis达到高性能的运行，mybatis没有这些性能参数，由mybatis自动调节。
### typeAliases类型别名
#### 使用
类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如:
````xml
<typeAliases>
  <typeAlias alias="Author" type="domain.blog.Author"/>
  <typeAlias alias="Blog" type="domain.blog.Blog"/>
  <typeAlias alias="Comment" type="domain.blog.Comment"/>
  <typeAlias alias="Post" type="domain.blog.Post"/>
  <typeAlias alias="Section" type="domain.blog.Section"/>
  <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
````
当这样配置时，Blog可以用在任何使用domain.blog.Blog的地方。  
也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:
````xml
<typeAliases>
  <package name="domain.blog"/>
</typeAliases>
````
每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。看下面的例子：
````java
@Alias("author")
public class Author {
    //...
}
````
#### 内建类型别名
这是一些为常见的 Java 类型内建的相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。

别名	|映射的类型
---|---
_byte	|byte
_long	|long
_short	|short
_int	|int
_integer	|int
_double	|double
_float	|float
_boolean	|boolean
string	|String
byte	|Byte
long	|Long
short	|Short
int	|Integer
integer	|Integer
double	|Double
float	|Float
boolean	|Boolean
date	|Date
decimal	|BigDecimal
bigdecimal	|BigDecimal
object	|Object
map	|Map
hashmap	|HashMap
list	|List
arraylist	|ArrayList
collection	|Collection
iterator	|Iterator

### mappers映射器
需要告诉 MyBatis 到哪里去找到这些语句，配置mapper.xml到全局SqlMapConfig.xml中  
使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。
#### 相对于类路径引用
````xml
<!-- 使用相对于类路径的资源引用 -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers>
````
#### 完全限定资源定位符
````xml
<!-- 使用完全限定资源定位符（URL） -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers>
````
#### 类的完全限定类名
````xml
<!-- 使用映射器接口实现类的完全限定类名 -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers>
````
#### 包内所有映射器
````xml
<!-- 将包内的映射器接口实现全部注册为映射器 -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>
````
### typeHandlers类型处理器
#### 介绍
无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 
#### 默认类型处理器
下表描述了一些默认的类型处理器。

类型处理器|	Java 类型|	JDBC 类型
---|---|---
BooleanTypeHandler	|java.lang.Boolean, boolean	|数据库兼容的 BOOLEAN
ByteTypeHandler	|java.lang.Byte, byte	|数据库兼容的 NUMERIC 或 BYTE
ShortTypeHandler	|java.lang.Short, short	|数据库兼容的 NUMERIC 或 SHORT INTEGER
IntegerTypeHandler	|java.lang.Integer, int	|数据库兼容的 NUMERIC 或 INTEGER
LongTypeHandler	|java.lang.Long, long	|数据库兼容的 NUMERIC 或 LONG INTEGER
FloatTypeHandler	|java.lang.Float, float	|数据库兼容的 NUMERIC 或 FLOAT
DoubleTypeHandler	|java.lang.Double, double	|数据库兼容的 NUMERIC 或 DOUBLE
BigDecimalTypeHandler	|java.math.BigDecimal	|数据库兼容的 NUMERIC 或 DECIMAL
StringTypeHandler	|java.lang.String	|CHAR, VARCHAR
ClobReaderTypeHandler	|java.io.Reader	|-
ClobTypeHandler	|java.lang.String	|CLOB, LONGVARCHAR
NStringTypeHandler	|java.lang.String	|NVARCHAR, NCHAR
NClobTypeHandler	|java.lang.String	|NCLOB
BlobInputStreamTypeHandler	|java.io.InputStream	|-
ByteArrayTypeHandler	|byte[]	|数据库兼容的字节流类型
BlobTypeHandler	|byte[]	|BLOB, LONGVARBINARY
DateTypeHandler	|java.util.Date	|TIMESTAMP
DateOnlyTypeHandler	|java.util.Date	|DATE
TimeOnlyTypeHandler	|java.util.Date	|TIME
SqlTimestampTypeHandler	|java.sql.Timestamp	|TIMESTAMP
SqlDateTypeHandler	|java.sql.Date	|DATE
SqlTimeTypeHandler	|java.sql.Time	|TIME
ObjectTypeHandler	|Any	|OTHER 或未指定类型
EnumTypeHandler	|Enumeration Type	|VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引）
EnumOrdinalTypeHandler	|Enumeration Type	|任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。
InstantTypeHandler	|java.time.Instant	|TIMESTAMP
LocalDateTimeTypeHandler	|java.time.LocalDateTime	|TIMESTAMP
LocalDateTypeHandler	|java.time.LocalDate	|DATE
LocalTimeTypeHandler	|java.time.LocalTime	|TIME
OffsetDateTimeTypeHandler	|java.time.OffsetDateTime	|TIMESTAMP
OffsetTimeTypeHandler	|java.time.OffsetTime	|TIME
ZonedDateTimeTypeHandler	|java.time.ZonedDateTime	|TIMESTAMP
YearTypeHandler	|java.time.Year	|INTEGER
MonthTypeHandler	|java.time.Month	|INTEGER
YearMonthTypeHandler	|java.time.YearMonth	|VARCHAR or LONGVARCHAR
JapaneseDateTypeHandler	|java.time.chrono.JapaneseDate	|DATE

#### 重写类型处理器
你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。   
具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。比如：
**ExampleTypeHandler.java**
````java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
````
**mybatis-config.xml**
````xml
<typeHandlers>
  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>
</typeHandlers>
````
[**详细查看Mybatis中文文档**](http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
## 输入映射
### #&#123; &#125; 
　　告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中。
### $&#123; &#125;
　　默认情况下,使用 #{} 格式的语法会导致 MyBatis 创建 PreparedStatement 参数并安全地设置参数（就像使用 ? 一样）。  
这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中插入一个不转义的字符串。比如，像 ORDER BY，你可以这样来使用：
通过parameterType完成输入映射，通过resultType和resultMap完成输出映射。
### 输入简单类型
````xml
<select id="selectUsers" parameterType ="int" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>
````
### 输入pojo类型
如果pojo类型的参数对象传递到了语句中，类的属性将会被查找，然后将它们的值传入预处理语句的参数中。
````xml
<insert id="insertUser" parameterType="User">
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
</insert>
````
### 输入pojo包装类型
**User.java**
````java
public class User {
	private int id;
	private String username;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
}
````
**UserCustom.java**
````java
public class UserCustom extends User {	
	//添加一些扩展字段
}
````
**UserQueryVo**
````java
public class UserQueryVo {
	//用户信息
	private User user;
	//自定义user的扩展对象
	private UserCustom userCustom;
	public User getUser() {
		return user;
	}
	public void setUser(User user) {
		this.user = user;
	}
	public UserCustom getUserCustom() {
		return userCustom;
	}
	public void setUserCustom(UserCustom userCustom) {
		this.userCustom = userCustom;
	}
}
````
````xml
<insert id="insertUser" parameterType="UserQueryVo" resultType="User">
  insert into users (id)
  values (#{user.id})
</insert>
````
## 输出映射
### 输出简单类型
如果查询记录结果集为一条记录且一列再使用返回简单类型。
````xml
<select id="selectUsers" parameterType ="int" resultType="String">
  select username
  from users
  where id = #{id}
</select>
````
### resultType
resultType ：指定输出结果的类型（pojo、简单类型、hashmap..），将sql查询结果映射为java对象 。  
***注意：sql查询的列名要和 resultType 指定 pojo 的属性名相同，指定相同 属性方可映射成功  
如果 sql 查询的列名要和 resultType 指定 pojo 的属性名全部不相同，list 中无法创建 pojo 对象。***

### resultMap
#### 介绍
resultMap：将sql查询结果映射为java对象。  
如果sql查询列名和最终要映射的pojo的属性名不一致，使用resultMap将列名和pojo的属性名做一个对应关系 （列名和属性名映射配置）
#### 属性
* constructor - 用于在实例化类时，注入结果到构造方法中
	+ idArg - ID 参数;标记出作为 ID 的结果可以帮助提高整体性能
	+ arg - 将被注入到构造方法的一个普通结果
* id – 一个 ID 结果;标记出作为 ID 的结果可以帮助提高整体性能
* result – 注入到字段或 JavaBean 属性的普通结果
* association – 一个复杂类型的关联;许多结果将包装成这种类型
	+ 嵌套结果映射 – 关联可以指定为一个 resultMap 元素，或者引用一个
* collection – 一个复杂类型的集合
	+ 嵌套结果映射 – 集合可以指定为一个 resultMap 元素，或者引用一个
* discriminator – 使用结果值来决定使用哪个 resultMap
	+ case – 基于某些值的结果映射
    	- 嵌套结果映射 – 一个 case 也是一个映射它本身的结果,因此可以包含很多相 同的元素，或者它可以参照一个外部的 resultMap。
       
#### id&result
##### 介绍
id 和 result 都将一个列的值映射到一个简单数据类型(字符串,整型,双精度浮点数,日期等)的属性或字段。
**解决列名不匹配的问题**
````xml
<select id="selectUsers" resultType="User">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password     as "hashedPassword"
  from some_table
  where id = #{id}
</select>
<resultMap id="userResultMap" type="User">
  <!--  id：要映射结果集的唯 一标识 ，称为主键
 		column：结果集的列名
 		property：type指定的哪个属性中
	-->
  <id column="user_id" property="id"/>
  <result column="user_name" property="username"/>
  <result column="hashed_password" property="password"/>
</resultMap>
<select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>
````
##### 属性



| 属性        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| property    | 映射到列结果的字段或属性。如果用来匹配的 JavaBeans 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称 property 的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。比如,你可以这样映射一些简单的东西: “username” ,或者映射到一些复杂的东西: “address.street.number” 。 |
| column      | 数据库中的列名,或者是列的别名。一般情况下，这和 传递给 resultSet.getString(columnName) 方法的参数一样。 |
| javaType    | 一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名 的列表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。 然而,如果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证期望的行为。 |
| jdbcType    | JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程,你需要对可能为 null 的值指定这个类型。 |
| typeHandler | 我们在前面讨论过的默认类型处理器。使用这个属性,你可以覆盖默 认的类型处理器。这个属性值是一个类型处理 器实现类的完全限定名，或者是类型别名。 |



### 高级结果映射

#### 关联
````xml
<association property="author" column="blog_author_id" javaType="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
</association>
````
#### 关联嵌套查询
````xml
<resultMap id="blogResult" type="Blog">
  <association property="author" column="author_id" javaType="Author" select="selectAuthor"/>
</resultMap>
<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>
<select id="selectAuthor" resultType="Author">
  SELECT * FROM AUTHOR WHERE ID = #{id}
</select>
````
#### 集合
````xml
<collection property="posts" ofType="domain.blog.Post">
  <id property="id" column="post_id"/>
  <result property="subject" column="post_subject"/>
  <result property="body" column="post_body"/>
</collection>
````
#### 集合嵌套查询
````xml
<resultMap id="blogResult" type="Blog">
  <collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>
</resultMap>
<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>
<select id="selectPostsForBlog" resultType="Post">
  SELECT * FROM POST WHERE BLOG_ID = #{id}
</select>
````
#### 详细
[详细参考Mybatis中文文档](http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps)
## sql片段
这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：
````xml
<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>
````
这个 SQL 片段可以被包含在其他语句中，例如：
````xml
<select id="selectUsers" resultType="map">
  select
    <include refid="userColumns"><property name="alias" value="t1"/></include>,
    <include refid="userColumns"><property name="alias" value="t2"/></include>
  from some_table t1
    cross join some_table t2
</select>
````
属性值也可以被用在 include 元素的 refid 属性里（
````xml
<include refid="${include_target}"/>
）或 include 内部语句中（
````
````xml
${prefix}Table
````
），例如：
````xml
<sql id="sometable">
  ${prefix}Table
</sql>

<sql id="someinclude">
  from
    <include refid="${include_target}"/>
</sql>

<select id="select" resultType="map">
  select
    field1, field2, field3
  <include refid="someinclude">
    <property name="prefix" value="Some"/>
    <property name="include_target" value="sometable"/>
  </include>
</select>
````

## 动态sql
　　MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。


　　虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。


　　动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

* if
* choose (when, otherwise)
* trim (where, set)
* foreach

### if
动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如：
````xml
<select id="findActiveBlogWithTitleLike"
     resultType="Blog">
  SELECT * FROM BLOG 
  WHERE state = ‘ACTIVE’ 
  <if test="title != null">
    AND title like #{title}
  </if>
</select>
````
　　这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果（细心的读者可能会发现，“title”参数值是可以包含一些掩码或通配符的）。


　　如果希望通过“title”和“author”两个参数进行可选搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。
````xml
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’ 
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
````
### choose, when, otherwise
　　有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。


　　还是上面的例子，但是这次变为提供了“title”就按“title”查找，提供了“author”就按“author”查找的情形，若两者都没有提供，就返回所有符合条件的 BLOG（实际情况可能是由管理员按一定策略选出 BLOG 列表，而不是返回大量无意义的随机结果）。
````xml
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
````
### trim, where, set
　　前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到“if”示例，这次我们将“ACTIVE = 1”也设置成动态的条件，看看会发生什么。
````xml
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG 
  WHERE 
  <if test="state != null">
    state = #{state}
  </if> 
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
````
### for
动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：
````xml
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
````
foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。


**``注意``** 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。
### bind
``bind `` 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：
````xml
<insert id="insert">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    <if test="_databaseId == 'oracle'">
      select seq_users.nextval from dual
    </if>
    <if test="_databaseId == 'db2'">
      select nextval for seq_users from sysibm.sysdummy1"
    </if>
  </selectKey>
  insert into users values (#{id}, #{name})
</insert>
````
### 详细
[详细参考Mybatis中文文档](http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html)

## 查询缓存
### 自定义缓存
　　MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。

　　默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行:
````xml
<cache/>
````
字面上看就是这样。这个简单语句的效果如下:

* 映射语句文件中的所有 select 语句将会被缓存。
* 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。
* 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。
* 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。
* 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。
* 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。

所有的这些属性都可以通过缓存元素的属性来修改。比如:
````xml
<cache
  eviction="FIFO"
  flushInterval="60000"
  size="512"
  readOnly="true"/>
````
　　这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。

可用的收回策略有:

* **LRU** – 最近最少使用的:移除最长时间不被使用的对象。
* **FIFO** – 先进先出:按对象进入缓存的顺序来移除它们。
* **SOFT** – 软引用:移除基于垃圾回收器状态和软引用规则的对象。
* **WEAK** – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。
默认的是 LRU。

　　flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。

　　size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。

　　readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。

### 使用第三方缓存方案
　　除了这些自定义缓存的方式, 你也可以通过实现你自己的缓存或为其他第三方缓存方案 创建适配器来完全覆盖缓存行为。
````xml
<cache type="com.domain.something.MyCustomCache"/>
````
　　这个示 例展 示了 如何 使用 一个 自定义 的缓 存实 现。type 属 性指 定的 类必 须实现 org.mybatis.cache.Cache 接口。这个接口是 MyBatis 框架中很多复杂的接口之一,但是简单 给定它做什么就行。
````java
public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}
````
　　要配置你的缓存, 简单和公有的 JavaBeans 属性来配置你的缓存实现, 而且是通过 cache 元素来传递属性, 比如, 下面代码会在你的缓存实现中调用一个称为 “setCacheFile(String file)” 的方法:
````xml
<cache type="com.domain.something.MyCustomCache">
  <property name="cacheFile" value="/tmp/my-custom-cache.tmp"/>
</cache>
````
　　你可以使用所有简单类型作为 JavaBeans 的属性,MyBatis 会进行转换。 And you can specify a placeholder(e.g. **``${cache.file}``**) to replace value defined at configuration properties.

　　从3.4.2版本开始，MyBatis已经支持在所有属性设置完毕以后可以调用一个初始化方法。如果你想要使用这个特性，请在你的自定义缓存类里实现 **``org.apache.ibatis.builder.InitializingObject ``**接口。
````java
public interface InitializingObject {
  void initialize() throws Exception;
}
````
　　记得缓存配置和缓存实例是绑定在 SQL 映射文件的命名空间是很重要的。因此,所有 在相同命名空间的语句正如绑定的缓存一样。 语句可以修改和缓存交互的方式, 或在语句的 语句的基础上使用两种简单的属性来完全排除它们。默认情况下,语句可以这样来配置:
````xml
<select ... flushCache="false" useCache="true"/>
<insert ... flushCache="true"/>
<update ... flushCache="true"/>
<delete ... flushCache="true"/>
````
　　因为那些是默认的,你明显不能明确地以这种方式来配置一条语句。相反,如果你想改 变默认的行为,只能设置 flushCache 和 useCache 属性。比如,在一些情况下你也许想排除 从缓存中查询特定语句结果,或者你也许想要一个查询语句来刷新缓存。相似地,你也许有 一些更新语句依靠执行而不需要刷新缓存。

### 参照缓存
　　这个特殊命名空间的唯一缓存会被使用或者刷新相同命名空间内 的语句。也许将来的某个时候,你会想在命名空间中共享相同的缓存配置和实例。在这样的 情况下你可以使用 cache-ref 元素来引用另外一个缓存。
````xml
<cache-ref namespace="com.someone.application.data.SomeMapper"/>
````
## Mybatis整合Spring
### Spring管理数据源
````xml
<!-- 加载jbdc.properties配置文件 -->
<context:property-placeholder location="classpath:jdbc.properties" />
<!-- 配置数据库连接池 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
	destroy-method="close">
	<property name="driverClassName" value="${jdbc.driver}" />
	<property name="url" value="${jdbc.url}" />
	<property name="username" value="${jdbc.username}" />
	<property name="password" value="${jdbc.password}" />
	<property name="initialSize" value="${jdbc.initialSize}"/>
	<property name="maxActive" value="${jdbc.maxActive}" />
	<property name="maxIdle" value="${jdbc.maxIdle}" />
	<property name="minIdle" value="${jdbc.minIdle}" />
	<property name="maxWait" value="${jdbc.maxWait}"/>
</bean>
````
### Spring管理SqlsessionFactory
spring/applicationContext-dao.xml
````xml
<!-- SqlsessionFactory -->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	<!-- 数据源 -->
	<property name="dataSource" ref="dataSource"/>
	<!-- mybatis配置文件 -->
	<property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml"/>
</bean>
````
### Spring配置mapper扫描器
````xml
<!-- 
MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，
自动创建到spring容器中，bean的id是mapper的类名（首字母小写）
 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<!-- 配置扫描包的路径
	如果要扫描多个包，中间使用半角逗号分隔
	要求mapper.xml和mapper.java同名且在同一个目录 
	 -->
	<property name="basePackage" value="cn.uhfun.webssm.mapper"/>
	<!-- 使用sqlSessionFactoryBeanName -->
	<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
</bean>
````
### 详细配置

**详细整合配置参考**  
Spring和Mybatis整合所需的配置文件（Dao层的配置文件）-–-applicationContext-dao-xml    
[Intellij idea 使用maven构建SSM项目](http://uhfun.cn/tech/2018/05/24/SSM项目整合.html)
